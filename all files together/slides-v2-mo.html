<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>RaukR 2021 - Final project</title>
    <meta charset="utf-8" />
    <meta name="author" content="Authors: AsEf, MAB, MaOk, Phil, ZLi" />
    <script src="libs/header-attrs-2.9/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link href="libs/countdown-0.3.5/countdown.css" rel="stylesheet" />
    <script src="libs/countdown-0.3.5/countdown.js"></script>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# RaukR 2021 - Final project
## ∝ Genome analyses - Human Chromosome 22 ∝
### Authors: AsEf, MAB, MaOk, Phil, ZLi
### NBS Training
### 2021/06/24

---

class:center, middle

# **GROUP MEMBERS**

## **Astradeni Efthymiadou**
## **Marika Oksanen**
## **Mónica Angulo-Bedoya**
## **Philip Dusart**
## **Zhuang Liu**

### .right[Advisor: Nina Norgren]     
---

class: center 
# **Project** - Analyses of a VCF format file with population allele frequencies of variants on human chromosome 22. 

## **What is a VCF file? How does it look like? **


![](https://user-images.githubusercontent.com/35312839/34796524-c4ddee7a-f623-11e7-99a3-4b6d193c894f.png)

![]](https://media.tenor.com/images/80a69c16ccffac7c6ec418b3d5e6827f/tenor.gif)
---
class: center

# Different nationalities, cultures, and backgrounds. Therefore different perspectives

.left[
## **Read as a tibble - option 1** - Working with pipelines

```r
#renv::install("tidyverse", "tibble")

require(tidyverse)
require(tibble)

tib_vcf = "chr22.1000g.copy.vcf" %&gt;%
  read.table() %&gt;%
  as_tibble() %&gt;%
  setNames(.,c("chrom", "pos", "new-var", "ref", "alt", "phred", 
               "filter", "format", "GT", paste0(rep("ind",2504),"-", 1:2504)))

head(tib_vcf[1:8,1:8])
```

```
## # A tibble: 6 x 8
##   chrom     pos `new-var` ref   alt   phred filter format                       
##   &lt;int&gt;   &lt;int&gt; &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;                        
## 1    22  1.61e7 .         G     A       100 PASS   AC=3;AF=0.000599042;AN=5008;~
## 2    22  1.61e7 .         C     T       100 PASS   AC=2;AF=0.000399361;AN=5008;~
## 3    22  1.61e7 .         C     T       100 PASS   AC=10;AF=0.00199681;AN=5008;~
## 4    22  1.61e7 .         G     A       100 PASS   AC=122;AF=0.024361;AN=5008;N~
## 5    22  1.61e7 .         G     C       100 PASS   AC=1;AF=0.000199681;AN=5008;~
## 6    22  1.61e7 .         G     A       100 PASS   AC=1;AF=0.000199681;AN=5008;~
```
]
---

```r
splitcol&lt;-function(x) {
  f&lt;-strsplit(x,"=")
  setNames(sapply(f,'[',2), sapply(f,'[',1))
}
#Making each row into a vector
fmt&lt;-lapply(strsplit(tib_vcf$format,";"), splitcol)

#new column names based on "format"
col_nam&lt;-unique(unlist(sapply(fmt, names)))

#extract data for all rows from each column
row_dat&lt;-do.call(rbind, lapply(fmt, '[', col_nam))

#put together the new data set (format split) with the original dataset
#be careful with the column number, so you introduce this data where you really want to.
vcf_det&lt;-cbind(tib_vcf[,1:7], row_dat[,1:12], tib_vcf[,9:2513])

head(vcf_det[1:8,1:12])
```

```
##   chrom      pos new-var ref alt phred filter  AC          AF   AN   NS    DP
## 1    22 16051493       .   G   A   100   PASS   3 0.000599042 5008 2504 22796
## 2    22 16054848       .   C   T   100   PASS   2 0.000399361 5008 2504 24413
## 3    22 16055937       .   C   T   100   PASS  10  0.00199681 5008 2504 19577
## 4    22 16056586       .   G   A   100   PASS 122    0.024361 5008 2504 29802
## 5    22 16061155       .   G   C   100   PASS   1 0.000199681 5008 2504 29105
## 6    22 16061873       .   G   A   100   PASS   1 0.000199681 5008 2504 13691
```
---
class: left, middle
## **Read as a tibble - option 2**
# Functions:


```r
info_extract &lt;- function(data = NULL, info = NULL){
  #split the string
  tmp_a &lt;- data %&gt;% str_split(., pattern = ";") %&gt;% unlist()
  tmp_b &lt;- lapply(tmp_a, FUN = function(x){
    return(x %&gt;% str_split(., pattern = "=") %&gt;% unlist())
  })
  tmp_c &lt;- do.call('rbind', tmp_b) %&gt;% t() %&gt;% as.data.frame()
  colnames(tmp_c) &lt;- tmp_c[1,]
  tmp_c &lt;- tmp_c[-1,]
  return(tmp_c[info])
}
```

---
class: middle

```r
source("z-project_Functions.R")
library(tidyverse)
library(vroom)
chr22vcf &lt;- readRDS("z-Data/chr22vcf.rds")
colnames(chr22vcf) &lt;- c("chr", "pos", "id", "ref", "alt", "qual", 
                        "filter", "info", "format", paste0("sm", 1:2504))
chr22vcf[1:10,1:15]
```

```
## # A tibble: 10 x 15
##    chr       pos id    ref   alt    qual filter info    format sm1   sm2   sm3  
##    &lt;chr&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
##  1 22     1.61e7 .     G     A       100 PASS   AC=3;A~ GT     0|0   0|0   0|0  
##  2 22     1.61e7 .     C     T       100 PASS   AC=2;A~ GT     0|0   0|0   0|0  
##  3 22     1.61e7 .     C     T       100 PASS   AC=10;~ GT     0|0   0|0   0|0  
##  4 22     1.61e7 .     G     A       100 PASS   AC=122~ GT     0|0   0|0   0|0  
##  5 22     1.61e7 .     G     C       100 PASS   AC=1;A~ GT     0|0   0|0   0|0  
##  6 22     1.61e7 .     G     A       100 PASS   AC=1;A~ GT     0|0   0|0   0|0  
##  7 22     1.61e7 .     G     A       100 PASS   AC=167~ GT     0|0   0|0   0|0  
##  8 22     1.61e7 .     T     A       100 PASS   AC=1;A~ GT     0|0   0|0   0|0  
##  9 22     1.61e7 .     C     T       100 PASS   AC=1;A~ GT     0|0   0|0   0|0  
## 10 22     1.61e7 .     G     A       100 PASS   AC=1;A~ GT     0|0   0|0   0|0  
## # ... with 3 more variables: sm4 &lt;chr&gt;, sm5 &lt;chr&gt;, sm6 &lt;chr&gt;
```
---
# Some results
## 1. Extract the sequencing info
### * Extract the SNP info

```r
# extract the info using self-written function, like the VT (Variant Type) is the type of SNP or INDEL
vcf_info_VT &lt;- sapply(chr22vcf$info, FUN = function(x) info_extract(data = x, info = "VT"))
vcf_info_VT &lt;- do.call("rbind", vcf_info_VT) %&gt;% as_tibble()
```
### * Plot the number of different types of variants

```r
require(ggbreak)
vt_plot &lt;- table(vcf_info_VT) %&gt;% as_tibble() %&gt;% 
  rename(VT = vcf_info_VT) %&gt;% 
  mutate(VT=parse_factor(VT, levels = c("SNP", "INDEL", "SNP,INDEL", "SV"))) %&gt;%
  ggplot(., aes(x=VT, y=n, color = VT, fill=VT)) +   geom_bar(stat="identity")  + scale_color_manual(values = c("#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3")) +
  scale_fill_manual(values = c("#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3")) +
  geom_text(aes(label=n), vjust=1.6, color="black", size=4) + 
  labs(x="", y="Frequency", title = "Variant Numbers") +
  theme_classic() + theme(legend.position = "none") +
  scale_y_break(c(20, 700), scales=0.5) +   scale_y_break(c(740,19000), scales=1)
```
---


```r
vt_plot
```

&lt;img src="slides-v2-mo_files/figure-html/unnamed-chunk-7-1.png" style="display: block; margin: auto;" /&gt;

---
class:left, middle
## 2. Extract and process the population info 
### * Extract populations info


```r
ori &lt;- readRDS("z-Data/ALL.chr22.origin.rds")
#Just need the sample information
sm_info &lt;- ori[1,] %&gt;% t() %&gt;% as_tibble() %&gt;% slice(-c(1:9))
colnames(sm_info) &lt;- "Sample_name"
all_sminfo &lt;- vroom("z-Data/igsr_samples.tsv")
colnames(all_sminfo) &lt;- gsub(" ","_",colnames(all_sminfo))
#Get the sample info what we need for our project
sm_info &lt;- sm_info %&gt;% 
  left_join(., all_sminfo, by=c("Sample_name" = "Sample_name"))
#delete the temporary files
rm(ori, all_sminfo)
```

---
class: left, middle
## 3. Draw a map of the distribution of samples
### * Draw the map of population distribution


```r
pop_loc &lt;- vroom("z-Data/igsr_populations.tsv")
colnames(pop_loc) &lt;- gsub(" ","_",colnames(pop_loc))

#add the population latitude and longitude
uni_pop_n &lt;- str_split(sm_info[["Population_name"]], pattern = ",") %&gt;% unlist() %&gt;% sort() %&gt;% table() %&gt;% as_tibble()
colnames(uni_pop_n)[1] &lt;- "Population_name"
uni_pop &lt;- str_split(sm_info[["Population_name"]], pattern = ",") %&gt;% unlist() %&gt;% unique() %&gt;% sort()
sm_loc &lt;- pop_loc %&gt;% select(3:6, 9) %&gt;% 
  filter(Population_name %in% uni_pop) %&gt;% 
  left_join(., uni_pop_n, by=c("Population_name" = "Population_name")) %&gt;% 
  distinct(Population_name, n, .keep_all = TRUE)
```

---
### *Ploting map...

```r
require(ggplot2)
require(maps)
require(ggrepel)
#Get the info of world map
world &lt;- map_data("world")
map_plot &lt;- ggplot() +
  geom_polygon(data = world, aes(x=long, y = lat, group = group, fill=group),  alpha=0.3, show.legend = FALSE) + #fill="grey",
  geom_point(data=sm_loc, aes(x=Population_longitude, y=Population_latitude, color=Population_name, size=n), alpha=1, show.legend = FALSE) +
  scale_size_continuous(range = c(1,4), breaks = c(seq(20,120, by=20))) + theme_void() +   labs(caption = "RaukR 2021 Genomic Data Project: Population Distribution") +   theme(plot.background = element_rect(fill = "white", color = NA), panel.background = element_rect(fill = "white", color = NA), 
    legend.background = element_rect(fill = "white", color = NA)) +
  geom_text_repel(data = sm_loc, mapping = aes(x=Population_longitude, y=Population_latitude, label=Population_name), 
    nudge_x = .15,  box.padding = 0.5, nudge_y = 1.1, segment.curvature = 0.1, segment.ncp = 3, segment.angle = 20, max.overlaps = 20) 
```
.center[![](https://media1.tenor.com/images/3a0c9909b542717ce9f651d07c4d4592/tenor.gif?itemid=8985245)]

---
# LOOK AT THIS MAP!!!


```r
map_plot
```

&lt;img src="slides-v2-mo_files/figure-html/unnamed-chunk-11-1.png" style="display: block; margin: auto;" /&gt;

---
# **Other option to read the .vcf file: using vcfR package **

### Now let's see how to develop packages to analyze genomes.

.center[This package can be used to get summary numbers of a vcf file, including what variants are included and how many of them. It is also possible to count how many times different variant types occur in the genotype data of the vcf file.]





```r
knitr::opts_chunk$set(eval = FALSE, include = FALSE)
#library(RaukRGenome)
```
---
class: center, middle
![](https://monophy.com/media/8ujkvy3gJ0fGHHb5gx/monophy.gif)

Slides created via the R package [**xaringan**]
.left[(https://github.com/yihui/xaringan)]
.left[(https://spcanelon.github.io/xaringan-basics-and-beyond/slides)]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
